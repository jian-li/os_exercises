#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
答：最大的区别是UEFI能够运行与32位和64位模式，突破了BIOS的16位代码的寻址能力，而且UEFI采用模块化，C语言风格的参数堆栈传递方式，动态链接的形式构建系统，比BIOS更易于实现，容错和纠错特性也更强。
 1. 描述PXE的大致启动流程。
答：1。通过UDP协议发送受限广播(255.255.255.255),目标端口67, 是DHCP命令中的DHCP 
discover,带PXEClient标志,并在UDP 68端口监听。
2。DHCP服务器在67端口收到请求后,通过UDP协议发送受限广播(255.255.255.255)，目标端口68,是DHCP命令中的DHCP offer,附带 客户端ip,网关,tftp服务器ip,子网掩码,可引导的文件名等.
3。客户机在68端口收到服务器回复的信息,客户机配置自身ip，从此时起，客户机可以使用单播通讯了。
4。客户端通过tftp协议发送获取引导文件的命令,并将获取的引导文件存放在地址 0:7c00 （第3步中获取的引导文件名）.
5.跳转到0:7c00开始执行引导文件中的代码,从此时起cpu控制权己交给引导文件.

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
答：1、电源自检程序开始运行
　　2、主引导记录被装入内存，并且程序开始执行
　　3、活动分区的引导扇区被装入内存
　　4、NTLDR从引导扇区被装入并初始化
　　5、将处理器的实模式改为32位平滑内存模式
　　6、NTLDR开始运行适当的小文件系统驱动程序。
小文件系统驱动程序是建立在NTLDR内部的，它能读FAT或NTFS。
　　7、NTLDR读boot.ini文件
　　8、NTLDR装载所选操作系统
如果windows NT/windows 2000/windows XP/windows server 2003这些操作系统被选择，NTLDR运行Ntdetect。对于其他的操作系统，NTLDR装载并运行Bootsect.dos然后向它传递控制。windows NT过程结束。
　　9.Ntdetect搜索计算机硬件并将列表传送给NTLDR，以便将这些信息写进\\HKE Y_LOCAL_MACHINE\HARDWARE中。
　　10.然后NTLDR装载Ntoskrnl.exe，Hal.dll和系统信息集合。
　　11.Ntldr搜索系统信息集合，并装载设备驱动配置以便设备在启动时开始工作
　　12.Ntldr把控制权交给Ntoskrnl.exe，这时,启动程序结束,装载阶段开始
 
1. 了解GRUB的启动流程。
答：当系统加电后，固化在BIOS中的程序首先对系统硬件进行自检，自检通过后，就加载启动磁盘上的MBR，并将控制权交给MBR中的程序(stage1)，stage1执行，判断自己是否GRUB，如果是且配置了stage1_5，则加载stage1_5，否则就转去加载启动扇区，接着，stage2被加载并执行，由stage2借助stage1_5驱动文件系统，并查找grub.conf，显示启动菜单供用户选择，然后根据用户的选择或默认配置加载操作系统内核，并将控制权交给操作系统内核，由内核完成操作系统的启动。
 1. 比较NTLDR和GRUB的功能有差异。
答：ntldr功能很少，只能引导win，只能装在硬盘；
grub是第三方操作系统引导器，可以引导硬盘，光盘，网络，U盘，winxp，winpe，win7，linux，dos，……
 
1. 了解u-boot的功能。
答：*系统引导支持NFS挂载、RAMDISK(压缩或非压缩)形式的根文件系统；支持NFS挂载、从FLASH中引导压缩或非压缩系统内核；
* 基本辅助功能强大的操作系统接口功能；可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤以Linux支持最为强劲；支持目标板环境参数多种存储方式，如FLASH、NVRAM、EEPROM；
* CRC32校验可校验FLASH中内核、RAMDISK镜像文件是否完好；
* 设备驱动串口、SDRAM、FLASH、以太网、LCD、NVRAM、EEPROM、键盘、USB、PCMCIA、PCI、RTC等驱动支持；
* 上电自检功能SDRAM、FLASH大小自动检测；SDRAM故障检测；CPU型号；
* 特殊功能XIP内核引导；

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
答：中断：硬盘读写中断，键盘中断，网络传输中断等；
　　异常：内存读写异常，除零异常等；
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

```
答：Linux系统调用有上百个，根据功能主要可以分为文件操作，进程管理，内存管理等；
Linux的系统调用通过int 80h实现，用系统调用号区分入口函数；
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 
 ```
答：ucore的系统调用有二十几个，主要分为文件操作，进程管理和内存管理等。
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 
答：
objdump:显示目标文件的详细信息；
nm:列出目标文件中的符号
file:检测文件类型
系统调用是应用程序和系统之间的接口，应用程序运行在用户态，不具有访问底层的特权，只能通过系统调用访问系统核心功能。系统调用就是向操作系统提出特权请求，然后应用程序等待
系统调用的返回。
 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 答：strace常用来跟踪进程执行时的系统调用和所接收的信号，可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
应用程序使用API进行系统调用，一旦进行系统调用，操作系统保护现场，取系统调用功能号并寻找子程序入口，并转移到子程序，向外部显示器写入字符，写入完成后恢复现场并返回。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
答：系统调用的参数传递代码：
　　　　　 arg[0] = tf->tf_regs.reg_edx;
           arg[1] = tf->tf_regs.reg_ecx;
           arg[2] = tf->tf_regs.reg_ebx;
           arg[3] = tf->tf_regs.reg_edi;
           arg[4] = tf->tf_regs.reg_esi;
取当前寄存器中的edx,ecx,ebx,edi和esi作为参数，进行系统调用。
 1. ucore的系统调用中返回结果的传递代码分析。
答：
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
答：ret  弹出一个参数，给ip，返回
ret 弹出2个参数，一个给ip,一个给 cs
iret 弹出 3个参数，一个给ip,一个给 cs ,一个给flag标志位 
int用于系统调用，iret是中断返回；
call用于函数调用，ret是函数返回。
